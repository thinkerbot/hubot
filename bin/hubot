#!/bin/bash

MY_DIR="$( cd "$( dirname $0 )" && pwd)"

if [ -z "$HUBOT_PLUGINS_DIR" ]
then
  export HUBOT_PLUGINS_DIR=$MY_DIR/plugins
fi

if [ -z "$HUBOT_ADAPTERS_DIR" ]
then
  HUBOT_ADAPTERS_DIR=$MY_DIR/adapters
fi


usage() {
cat <<EOF
usage: $0 options

OPTIONS:
  -h   Show this message
  -l   List adapters
  -p   List plugins
  -a   Adapter to use (default: shell)

EOF
}

PLUGINS=""
ADAPTERS=""
ADAPTER="$HUBOT_ADAPTERS_DIR/shell"

# This is the only Hubot function available to the adapters
# It is up to the adapters how to execute the plugins
# (i.e. in serial or parallel) and what do do with the output.
list_plugins() {
    PLUGINS=`find $HUBOT_PLUGINS_DIR -maxdepth 1 -type f -perm -o+x`
}

export -f list_plugins
#export $PLUGINS

list_adapters() {
    ADAPTERS=`find $HUBOT_ADAPTERS_DIR/* -maxdepth 1 -type d`
}


_print_paths() {
    # Pretty-print adapter & plugin paths for the command line
    for p in $@
    do
        echo "  `basename $p`"
    done
}

while getopts "hlpa:" OPTION
do
  case $OPTION in
      h)
          usage
          exit 0
          ;;
      l)
          list_adapters
          echo "Available adapters"
          _print_paths $ADAPTERS
          exit 0
          ;;
      p)
          list_plugins
          echo "Available plugins"
          _print_paths $PLUGINS
          exit 0
          ;;
      a)
          ADAPTER="$HUBOT_ADAPTERS_DIR/$OPTARG"
          ;;
      ?)
          usage
          exit 0
          ;;
  esac
done

LISTEN="$ADAPTER/listen"
SAY="$ADAPTER/say"

if [ ! -e "$LISTEN" ]
then
    echo "Adapter listen command not found: $LISTEN"
    exit 1
fi

if [ ! -e "$SAY" ]
then
    echo "Adapter say command not found: $SAY"
    exit 1
fi

if [ ! -x "$LISTEN" ]
then
    echo "Adapter listen command is not executable: $LISTEN"
    exit 1
fi

if [ ! -x "$SAY" ]
then
    echo "Adapter say command is not executable: $SAY"
    exit 1
fi

#
# setup inbox fifos
#

list_plugins

inbox_dir="var/hubot/inbox"
rm "$inbox_dir"/*
mkdir -p "$inbox_dir"

# Launch a hang process to hold open the fifos and thereby prevent a broken
# pipe if one of the plugins exits prematurely.  Set a trap to cleanup the
# hang loop on exit.
hangpids=" "
trap '
status=$?
for id in ${hangpids}
do kill -9 "${id}"
done
exit $status
' INT TERM EXIT

for plugin in $PLUGINS
do
  inbox="$inbox_dir/$(basename "$plugin")"

  if ! [ -e "$inbox" ]
  then mkfifo "$inbox"
  fi

  while true; do sleep 1; done < "$inbox" > "$inbox" & 
  hangpids="${hangpids}$! "
done

#
# launch plugins
#

for plugin in $PLUGINS
do
  inbox="$inbox_dir/$(basename "$plugin")"
  (
    trap "ln -fs /dev/null '$inbox'; exit"  INT TERM EXIT
    $plugin < "$inbox" | $SAY
  ) &
done

$LISTEN | tee "$inbox_dir"/* >/dev/null
